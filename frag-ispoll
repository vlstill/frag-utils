#!/usr/bin/env python3
from __future__ import annotations

import argparse
import enum
import common
import isapi.files
import os
import os.path
import psycopg2  # type: ignore
import re
import sys
import typing

from dataclasses import dataclass
from datetime import datetime
from common import fprint
from isapi.files import FileMeta
from typing import Optional, TypeVar, Iterable, Dict, List
from common import to_utc

τ = TypeVar("τ")


def cmdparser() -> argparse.ArgumentParser:
    return common.cmdparser("Poller for connecting IS submission folders "
                            "to FRAG")


class MultiFile(enum.Enum):
    Disabled = enum.auto()
    Any = enum.auto()
    All = enum.auto()

    @staticmethod
    def parse(raw: str) -> MultiFile:
        raw = raw[0].upper() + raw[1:].lower()
        return MultiFile.__members__[raw]


class Assignment(common.BaseAssignment):
    RE_ANY = re.compile(".*")

    def __init__(self, raw: dict, name: str, config: Config,
                 db: psycopg2.connection) -> None:
        super().__init__(raw, name, config, db)
        assert "source" in self.raw
        source = self.raw['source']
        if source.startswith('/'):
            self.sources = [source]
        else:
            assert "sources" in config.raw
            assert source in config.raw["sources"]
            self.sources = config.raw["sources"][source]
        self.name_template: Optional[str] = self.raw.get('name template')
        self.multifile = MultiFile.parse(self.raw.get('multifile', 'disabled'))

    def __str__(self) -> str:
        return self._str(f"sources = {self.sources} "
                         f"template = {self.name_template} "
                         f"multifile = {self.multifile}")

    def canonic_file_name(self, filem: FileMeta) -> Optional[str]:
        assert self.file_names is not None
        if self.name_template is None \
                and self.multifile is MultiFile.Disabled:
            return self.file_names[0]

        if self.name_template is not None:
            if Assignment._match_template(self.name_template,
                                          filem.shortname):
                return self.name_template

        for name in self.file_names:
            if Assignment._match_template(name, filem.shortname):
                return name
        return None

    def match(self, filem: FileMeta) -> bool:
        return self.canonic_file_name(filem) is not None

    @staticmethod
    def _match_template(raw_name_template: str, real_name: str) -> bool:
        name, ext = os.path.splitext(raw_name_template)
        return re.fullmatch(fr"(\d+-)?(\w+-)?{name}(_[a-z]+)?[.]{ext[1:]}",
                            real_name) is not None


class Config(common.BaseConfig):
    def assignments(self, db: psycopg2.connection) -> Iterable[Assignment]:
        asgns = self._assignments()
        return (Assignment(raw, name, self, db)
                for name, raw in asgns.items())


@dataclass
class Submission:
    person_id: int
    timestamp: datetime
    files: Dict[str, FileMeta]
    dirty: bool

    def __init__(self, db: psycopg2.connection, asgn: Assignment,
                 first_file: FileMeta) -> None:
        self.person_id = first_file.author
        self.timestamp = first_file.change_time
        name = asgn.canonic_file_name(first_file)
        assert name is not None
        self.files = {name: first_file}
        self.dirty = not file_processed(first_file, db)
        self.asgn = asgn

    def add_file(self, db: psycopg2.connection, filem: FileMeta) -> None:
        assert self.person_id == filem.author
        name = self.asgn.canonic_file_name(filem)
        assert name is not None
        if name not in self.files \
                or self.files[name].change_time < filem.change_time:
            self.timestamp = max(self.timestamp, filem.change_time)
            self.files[name] = filem
            self.dirty = self.dirty or not file_processed(filem, db)

    def is_todo(self) -> bool:
        if self.asgn.multifile is not MultiFile.All:
            return self.dirty
        assert self.asgn.file_names is not None
        return self.dirty and len(self.files) == len(self.asgn.file_names)


def poll(args: argparse.Namespace, config: Config) -> None:
    db = config.connect_db()

    isconn = isapi.files.Connection()
    for asgn in config.assignments(db):
        if not asgn.enabled:
            continue
        if asgn.id is None:
            fprint(f"Assignment {asgn.name} not in frag, skipping…",
                   file=sys.stderr)
            continue

        assert asgn.file_names is not None
        if len(asgn.file_names) != 1 and asgn.multifile is MultiFile.Disabled:
            fprint(f"W: Assignment {asgn.name} has "
                   f"{len(asgn.file_names)} files defined in frag,"
                   " but it needs to have 1 (no multifile set). Skipping…",
                   file=sys.stderr)
            continue

        for sub in collect_submissions(isconn, db, asgn):
            process_submission(config, db, isconn, sub)


def collect_submissions(isconn: isapi.files.Connection,
                        db: psycopg2.connection, asgn: Assignment) \
                        -> List[Submission]:
    submissions: Dict[int, Submission] = {}
    for ispath in asgn.sources:
        try:
            dirm = isconn.list_directory(ispath)
            for filem in dirm.entries:
                if asgn.match(filem):
                    if filem.author in submissions:
                        submissions[filem.author].add_file(db, filem)
                    else:
                        submissions[filem.author] = Submission(db, asgn, filem)
        except isapi.files.FileDoesNotExistException:
            fprint(f"W: Directory does not exist: {ispath}", file=sys.stderr)

    return [sub for sub in submissions.values() if sub.is_todo()]


def get_ispath_id(filem: FileMeta, cur: psycopg2.cursor) -> Optional[int]:
    cur.execute("select id from frag_ispoll.ispath where path = %s",
                (filem.ispath,))
    if cur.rowcount == 0:
        return None
    assert cur.rowcount == 1
    return typing.cast(int, cur.fetchone()[0])


def file_processed(filem: FileMeta, db: psycopg2.connection) -> bool:
    with db.cursor() as cur:
        ispath_id = get_ispath_id(filem, cur)
        if ispath_id is None:
            return False
        cur.execute("select count(*) from frag_ispoll.processed"
                    "  where ispath_id = %s"
                    "    and objid = %s"
                    "    and change_time = %s",
                    (ispath_id, filem.objid, to_utc(filem.change_time)))
        return bool(cur.fetchone()[0])


def confirm_file(filem: FileMeta, db: psycopg2.connection) -> None:
    with db.cursor() as cur:
        cur.execute("insert into frag_ispoll.ispath (path)"
                    " values (%s)"
                    " on conflict do nothing"
                    " returning (id)",
                    (filem.ispath, ))
        res = cur.fetchone()
        ispath_id = res[0] if res is not None else get_ispath_id(filem, cur)
        assert ispath_id > 0
        cur.execute("insert into frag_ispoll.processed"
                    " (ispath_id, change_time, objid)"
                    " values (%s, %s, %s)"
                    " on conflict do nothing",
                    (ispath_id, to_utc(filem.change_time), filem.objid))


def process_submission(config: Config, db: psycopg2.connection,
                       isconn: isapi.files.Connection, sub: Submission) \
                       -> None:
    fprint("processing", sub, "…")
    assert sub.asgn.id is not None
    assert sub.asgn.file_names is not None
    common.submit_assignment(sub.asgn.id, sub.person_id, db,
                             [common.File(name,
                                          data=isconn.get_file(filem).data)
                              for name, filem in sub.files.items()],
                             sub.timestamp)

    for filem in sub.files.values():
        confirm_file(filem, db)
    db.commit()


def check_init_db(config: Config) -> None:
    with config.connect_db() as db:
        common.create_schema_if_not_exists("frag_ispoll", db)
        with db.cursor() as cur:
            cur.execute("create table if not exists frag_ispoll.ispath ("
                        "  id serial primary key,"
                        "  path bytea not null unique"
                        ")")
            cur.execute("create table if not exists frag_ispoll.processed ("
                        "  ispath_id integer not null,"
                        "  change_time timestamp without time zone not null,"
                        "  objid integer,"
                        "  constraint processed_ispath_id_ispath_id_fkey"
                        "    foreign key (ispath_id)"
                        "      references frag_ispoll.ispath(id),"
                        "  constraint processed_unique"
                        "    unique (ispath_id, change_time, objid)"
                        ")")
            db.commit()


if __name__ == "__main__":
    common.main(cmdparser, Config, check_init_db, poll)

# vim: colorcolumn=80 expandtab sw=4 ts=4
